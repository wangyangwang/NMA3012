--- 
layout: default 
---

<div>
    <h2>live Image Processing</h2>
    <p>Live Image Processing is the technique of recording seperate r, g, b value for each pixel in moving or live images, performing simple procedual alteration and recombining them into new images.</p>
</div>

<div>
    <h2>Load video</h2>
    <p>Load in a pre-recorded video, play/stop, scrub movie, using mouseX position as proximity</p>
    {% highlight js %}
        import processing.video.*;

Movie mov; //declare move object
float tempPos = width/2; //stores mouse position from the previous frame
float tempSpeed = 1;

void setup() {

  size(640, 360);
  mov = new Movie(this, "tickingclock.mp4"); //initialize move object
  mov.play(); //play movie once
  mov.loop(); //loop video when finished
}

void draw() {
    mov.read(); //start reading frames of movie according to its default sequence
    mov.speed(tempSpeed);
    image(mov, 0, 0); //draw movie at location 0, 0
    
//  interaction prototyping with mouse: control clock using mouseX position    
//  if (mouseX>width/2) {
//    mov.pause();
//  } else {
//    mov.play();
//  }

 
  if(abs((mouseX - tempPos))>0){
      // Ratio of mouse X over width
  float ratio = mouseX / (float) width;

 // The jump() function allows you to jump immediately to a point of time within the video. 
  // duration() returns the total length of the movie in seconds.  
  mov.jump(ratio * mov.duration()); 
  }
  tempPos = mouseX;
}
    {% endhighlight %}
</div>

<div>
    <h2>Live Image Caputure</h2>
    {% highlight js %} 
        import processing.video.*;

Capture video; //declare a capture object called video

void setup() {
  size(640, 480);
  println(Capture.list());

  // initialize video object, use the default camera at 320x240 resolution
  video = new Capture(this, 640, 480);
  video.start();
}

// An event for when a new frame is available, similar to mousePressed
void captureEvent(Capture video) {
  // Step 4. Read the image from the camera.
  video.read();
}

void draw() {
  // Step 5. Display the video image.
  image(video, 0, 0);
}
    {% endhighlight %}
</div>

<div>
    <h2>Live Image Manipulation</h2>
    <p>Pixel Sorting is one of the most commonly used ways to manipulate static and live image. After recording rgb value of each pixel, the algorithm draws a horizontal or vertical strip based on the location and color value of the original pixel.</p>
    <p>Conceptual and digital artist Kim Asendorf takes as his media internet data, codes, and computer signals, manipulating them to produce visualizations, sculptures, and applications, as well as his own original file formats. A computer science graduate, Asendorf thinks of his experimental process as writing concept into algorithms: “the programming implements a random factor,” he has said. “It’s like drawing an image with closed eyes.” In 2010, Kim Ascendorf invented a pixel sorting algorithm and used it to produce a series of images called <a href="http://kimasendorf.com/mountain-tour/">Mountain Tour. </a>The images went viral on the internet overnight and Kim hailed as the founding father of procedural based Glitch Art.</p>
    <p>Down load the Processing algorithm Kim released <a href="http://kimasendorf.com/data/ASDFPixelSort.zip">HERE</a> and try it out with your own image.</p>
    <p>Now, let's adapt a similar pixelsorting based approach on live image captured by our camera.</p>
    {% highlight js %} 
        import processing.video.*;
 
int numPixels;
int[] backgroundPixels;
Capture video;
 
void setup() {
  size(1280, 720, P3D);
  background(0);
  String[] cameras = Capture.list();
 
  if (cameras == null) {
    println("Failed to retrieve the list of available cameras, will try the default...");
    video = new Capture(this, 1280, 720);
  } if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
  } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(cameras[i]);
    }
 
    // The camera can be initialized directly using an element
    // from the array returned by list():
    video = new Capture(this, cameras[0]);
    
    // Start capturing the images from the camera
    video.start();
  }
}
 
void draw() {
  if (video.available() == true) {
    video.read();
   
    video.loadPixels();
     
    for (int y = 0; y<height; y+=1 ) {
      for (int x = 0; x<width; x+=1) {
        int loc = x + y*video.width;
        float r = red (video.pixels[loc]);
        float g = green (video.pixels[loc]);
        float b = blue (video.pixels[loc]);
        float av = ((r+g+b)/3.0);
      
      pushMatrix();
      translate(x,y);
      stroke(r,g,b);
      if (r > 50 && r < 255) {
          line(0,0,(av-100)/3,0); //change these values to alter the length. The closer to 0 the longer the lines. 
         // you can also try different shapes or even bezier curves instead of line();
      }
      popMatrix(); 
     }
   }
 }
}
    {% endhighlight %}
</div>

<div>
    <h2>Live Image Manipulation</h2>
    {% highlight js %} 
    
    {% endhighlight %}
</div>



